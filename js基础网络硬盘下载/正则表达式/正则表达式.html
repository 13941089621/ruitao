<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>

	<body>
		<script>
			/*
			 正则表达式
			Regular Expriession 使用单个字符串来描述和匹配一系列
			符合某个语法规则的字符串
										
			分为两种字符
			1.原意文本字符
			例如:a  匹配的就是a  123匹配的就是123
			2.元字符(特殊字符 在正则表达式中表达特殊含义的字符)
			.	匹配除换行符以外的任意字符				
			^	匹配字符串的开始
			$	匹配字符串的结束
			|   指名两项之间选择一个
			\   将一个字符标记为特殊字符或元义字符(转义字符)
			()  标记子表达式的开始和结束
			{}  标记限定表达式的开始和结束
			[]  标记中括号表达式的开始和结束
			\w	匹配字母或数字或下划线或汉字
			\s	匹配任意的空白符
			\d	匹配数字
			\b	匹配单词的开始或结束
			*/

			//2.字符类
			//使用[]来构建一个字符类
			//例如使用[abc]把a或b或c归为一类,表达式可以配置这类的字符
			//var str="a1b2c4d5";
			//str = str.replace(/[abc]/g,"X");
			//alert(str);
			
		

			//字符取反
			//使用元字符^创建 反向类/负向类
			//匹配不属于某类的内容
			//例如:[^abc] 不是a或b或c内容
			//var str="a1b2c4d5";
			//str = str.replace(/[^abc]/g,"X");
			//alert(str); 

			//3.范围类
			//例如[a-z] 匹配a到z的任意字符
			//[A-Z] 匹配A到Z的任意字符
			//[0-9] 匹配0~9的任意数字
			//[a-zA-Z]
			//[a-zA-Z0-9]
			//var str="a1b2c4d5x7y8z9";
			//str = str.replace(/[a-z]/g,"X");
			//alert(str); 	

			//如果想匹配在范围类里想匹配横线例如2016-08-31
			//[0-9-]
			//var str="2016-08-31";
			//str = str.replace(/[0-9-]/g,"X");
			//alert(str);

			//预定义类
			// .  等价[^\r\n] 除了换行符和回车符之外的所有字符
			// \d 等价[0-9]  匹配数字
			// \D 等价[^0-9] 匹配非数字
			// \s 等价[\t\n\x0B\f\r] 匹配空白符
			// \S 等价[^\t\n\x0B\f\r] 匹配非空白符
			// \w 等价[a-zA-Z_0-9] 字母数字下划线
			// \W 等价[^a-zA-Z_0-9] 非字母数字下划线

			//4.边界符
			// ^  以xxx开始
			// $  以xxx结束
			// \b 单词边界
			// \B 非单词边界
			//var str = "This is a girl";
			//str = str.replace(/\bis\b/g,"0");
			//alert(str);

			//var str = "This is a girl";
			//str = str.replace(/\Bis\b/g,"0");
			//alert(str);

			//5.量词
			//匹配连续出现的字符
			//*   匹配零次或多次
			//+   匹配一次或多次
			//?   匹配零次或一次
			//{n} 匹配n次
			//{n,m} 匹配n到m次
			//{n,} 匹配n到任意次
			//例如 配10个数字  \d\d\d\d\d\d\d\d\d\d
			//可以使用 \d{10}

			//6.贪婪模式 
			//默认使用贪婪模式 尽可能多的匹配
			//var str = "12345678";
			//var str = str.replace(/\d{3,6}/g,"X");
			//alert(str);

			//7.非贪婪模式
			//让正则表达式尽可能少的匹配 一旦匹配成功不再继续尝试
			//在量词后面加上?
			//var str = "12345678";
			//var str = str.replace(/\d{3,6}?/g,"X");
			//alert(str);

			//8.分组
			//例如:我想匹配baidu 3次,如果我写 baidu{3} 
			//实际上呢是u匹配三次
			//用()进行分组(baidu){3} 匹配baidu 3次

			//9.或
			//例如:(|) 再分组中使用|表示或的意思
			//var str = "iloveyou";
			//str = str.replace(/(lo|ve)?/g,"X");
			//alert(str);

			//10.反向引用
			//2016-08-31 想替换成 08/31/2016
			//使用$符可以获取分组内的内容
			//var str = "2016-08-31";
			//str = str.replace(/(\d{4})-(\d{2})-(\d{2})/, "$2-$3-$1");
			//alert(str);
			//忽略分组(?:\d{4}) 在分组前加上?:
			
			//11.前瞻
			//正则表达式从文本头部向尾部开始解析,文本尾部方向,成为"前"
			//前瞻就是正则表达式匹配到规则的时候,向前检查是否符合断言
			//后顾(Javascript不支持后顾)
			//符合和不符合断言成为肯定正向/匹配和否定/负向匹配
			
			//正向前瞻 exp(?=assert) exp代表正则表达式 assert代表断言也是正则表达式
			//负向前瞻 exp(?!=assert)
			//var str = "a2*3";
			//var str = str.replace(/\w(?=\d)/gim,"X")
			//alert(str);
			//修饰符
			//g 全文搜索
			//i 忽略大小写
			//m 多行检索
		</script>
	</body>

</html>
